<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0"><title>Arduino and Raspberry Pi communicating over 2.4GHz with cheap nRF24L01+ modules | Cross Dominant</title><meta name="description" content="Mixed Laterality since 1968"><meta property="og:title" content="Arduino and Raspberry Pi communicating over 2.4GHz with cheap nRF24L01+ modules | Cross Dominant"><meta property="og:type" content="article"><meta property="og:description" content="Mixed Laterality since 1968"><meta property="og:url" content="http://conoro.github.io/blog/arduino-and-raspberry-pi-communicating-over-2-4ghz-with-cheap-nrf24l01-modules"><meta property="og:image" content="http://conoro.github.io/images/logo.png"><meta property="og:site_name" content="Cross Dominant"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@conoro"><meta name="twitter:creator" content="@conoro"><meta name="twitter:title" content="Arduino and Raspberry Pi communicating over 2.4GHz with cheap nRF24L01+ modules | Cross Dominant"><meta name="twitter:description" content="Mixed Laterality since 1968"><meta name="twitter:image" content="http://conoro.github.io/images/logo.png"><link rel="author" href="https://plus.google.com/+ConorONeill/posts"><link rel="shortcut icon" href="/favicon.ico"><link rel="alternate" type="application/rss+xml" title="Cross DominantRSS Feed" href="/blog/rss.xml"><link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Lato:400,300,300italic,400italic,700,700italic"><link rel="stylesheet" href="http://fonts.googleapis.com/css?family=Lekton"><link rel="stylesheet" href="/css/main.css"><!--[if lt IE 9]><script src="/js/html5shiv.js"></script><![endif]--><script type="text/javascript">var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-88610-4']);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();</script></head><body class="page-blog blog-arduino-and-raspberry-pi-communicating-over-2-4ghz-with-cheap-nrf24l01-modules"><header class="masthead"><div class="container"><h1><a href="/">Cross Dominant</a></h1></div><div class="img"></div></header><div class="content"><div class="container"><article class="post"><h1 class="lg title">Arduino and Raspberry Pi communicating over 2.4GHz with cheap nRF24L01+ modules</h1><h2 class="sm date">1378565517000</h2><h1>&quot;Arduino and Raspberry Pi communicating over 2.4GHz with cheap nRF24L01+ modules&quot;</h1>
<p>I&#39;ve had a lot of fun over the past year messing with wireless comms. The 433Mhz/434MHz dirt-cheap modules are fantastic for Arduino, particularly when used with the <a href="http://www.airspayce.com/mikem/arduino/">VirtualWire library</a> which makes them trivial to setup. I&#39;ve been able to send sensor data and RC car commands using them with just a few lines of code. However, there isn&#39;t a version of VirtualWire for RaspberryPi and I don&#39;t have the time/skills to port the Arduino one.</p>
<p>I&#39;ve also mentioned multiple projects using those HC05/HC06 serial Bluetooth modules. Again, dead easy to use and they connect Arduinos to PCs, Raspberry Pis and mobile phones. They are a bit pricey tho.</p>
<p>My latest experiments involve the Nordic Semiconductor nRF24L01+ modules. These cost <a href="http://www.ebay.ie/itm/1X-NRF24L01-2-4GHz-Antenna-Wireless-Transceiver-Module-For-Microcontroller-WST-/271265848197?pt=UK_BOI_Electrical_Test_Measurement_Equipment_ET&amp;hash=item3f28b45b85">approx 1.26 each on eBay</a> and strike me as the perfect middle ground between the two approaches above. They are cheap, work over a decent distance and have libraries available for both Arduino and Raspberry Pi.</p>
<p>However I spent nearly all of last weekend trying to get a Raspberry Pi talking to an Arduino using instructions in some <a href="http://arduino-for-beginners.blogspot.ie/2013/02/setup-nordic-nrf24l01-rf-modules-to.html">blogposts</a>. It turns out his instructions were a mix of incorrect text, links to wrong repos, self-contradictory blogposts and code/comments which also contradicted each other. Eventually by ignoring text/comments and just reading the code, I got the wiring right and the sample code working. Whilst I hugely appreciate someone putting time and effort into writing/improving Open Source code like this, it really is a bad idea to then wrap it in such error-riddled explanations.</p>
<p><a href="https://s3-eu-west-1.amazonaws.com/conoroneill.net/wp-content/uploads/2013/09/2013-09-07-15.34.49.jpg"><img class="aligncenter size-large wp-image-1157" alt="2013-09-07 15.34.49" src="https://s3-eu-west-1.amazonaws.com/conoroneill.net/wp-content/uploads/2013/09/2013-09-07-15.34.49-1024x556.jpg" width="584" height="317" /></a></p>
<p>To avoid you going down the same rabbit hole, this is what you need to do to get Arduino talking to RPi over nRF24L01+.</p>
<p><h2>Arduino Connections</h2>
Note that the module is 5V tolerant (apart from VCC) but just to be sure I used it with an <a href="http://www.elecfreaks.com/store/freaduino-leonardo-p-442.html">Elecfreaks Freaduino Leonardo</a> which has a physical switch to toggle between 3.3V and 5V. You could also use a <a href="https://www.sparkfun.com/products/11114">3.3V Pro Mini from Sparkfun like this</a>. It has worked fine on my 5V Uno too.</p>
<p><ul>
    <li>Arduino GND - Module Pin 1</li>
    <li>Arduino 3.3V - Module Pin 2</li>
    <li>Arduino Pin 8 - Module Pin 3</li>
    <li>Arduino Pin 9 - Module Pin 4</li>
    <li>Arduino Pin 13 - Module Pin 5</li>
    <li>Arduino Pin 11 - Module Pin 6</li>
    <li>Arduino Pin 12 - Module Pin 7</li>
    <li>Module Pin 8 Not Connected</li>
</ul></p>
<p><h2>Raspberry Pi Connections</h2>
The Raspberry Pi is 3.3V itself so can connect directly to the module. Here is the pin-out. Only pay attention to the pin numbers in the circles, not the names.</p>
<p><h2><a href="https://s3-eu-west-1.amazonaws.com/conoroneill.net/wp-content/uploads/2013/09/RPi-pinout-GPIO.png"><img class="aligncenter size-large wp-image-1149" alt="RPi pinout GPIO" src="https://s3-eu-west-1.amazonaws.com/conoroneill.net/wp-content/uploads/2013/09/RPi-pinout-GPIO.png" width="584" height="275" /></a></h2></p>
<p><ul>
    <li>RPi Pin 6 - Module Pin 1</li>
    <li>RPi Pin 1 - Module Pin 2</li>
    <li>RPi Pin 22 - Module Pin 3</li>
    <li>RPi Pin 24 - Module Pin 4</li>
    <li>RPi Pin 23 - Module Pin 5</li>
    <li>RPi Pin 19 - Module Pin 6</li>
    <li>RPi Pin 21 - Module Pin 7</li>
    <li>Module Pin 8 Not Connected</li>
</ul></p>
<p><h2>Building The Library on RPi</h2></p>
<p><pre>mkdir ~/gitwork
cd gitwork
git clone<a href="https://github.com/stanleyseow/RF24.git">https://github.com/stanleyseow/RF24.git</a>
cd RF24
cd librf24-rpi/librf24
make
sudo make install
sudo ldconfig -v | grep librf
cd examples/
make</pre></p>
<p><h2>Arduino Libraries</h2>
You need to install the Arduino libraries:</p>
<p><ul>
    <li>Grab a <a href="https://github.com/stanleyseow/RF24/archive/master.zip">zip file of all of the latest code from Github</a>.</li>
    <li>Unzip that file</li>
    <li>Rename the directory from RF24-master to RF24</li>
    <li>Delete all of its sub-directories</li>
    <li>Copy the overall RF24 directory to the libraries directory of your Arduino IDE install. In my case that becomes: C:\Program Files (x86)\Arduino\libraries\RF24</li>
    <li>The nRF24L01.h and RF24.h includes should now work in your code when you run the IDE</li>
</ul></p>
<p><h2>Arduino Sketch</h2>
This is my quick and dirty hack of the author&#39;s Arduino sending sketch. It removes all of the LCD display stuff and only returns one sensor value. In my case that&#39;s a single switch on Digital Pin 6 which is either open or closed. I&#39;ll post a tidier one with updated comments when I have it completed.</p>
<p>[sourcecode]
/<em>
Written by Stanley Seow
stanleyseow@gmail.com
</em>/</p>
<h1>include <SPI.h></h1>
<h1>include &quot;nRF24L01.h&quot;</h1>
<h1>include &quot;RF24.h&quot;</h1>
<h1>include &quot;printf.h&quot;</h1>
<h1>define RF_SETUP 0x17</h1>
<p>// Set up nRF24L01 radio on SPI pin for CE, CSN
RF24 radio(8,9);</p>
<p>// Example below using pipe5 for writing
const uint64_t pipes[2] = { 0xF0F0F0F0E1LL, 0x7365727631LL };</p>
<p>char receivePayload[32];
uint8_t counter=0;
int inPin = 6; // button connected to digital pin 6</p>
<p>void setup(void)
{</p>
<p>// Conor Switch
pinMode(inPin, INPUT);</p>
<p>Serial.begin(57600);</p>
<p>printf_begin();
printf(&quot;Sending nodeID &amp; 1 sensor data\n\r&quot;);</p>
<p>radio.begin();</p>
<p>// Enable this seems to work better
radio.enableDynamicPayloads();</p>
<p>radio.setDataRate(RF24_1MBPS);
radio.setPALevel(RF24_PA_MAX);
radio.setChannel(76);
radio.setRetries(15,15);</p>
<p>radio.openWritingPipe(pipes[0]);
radio.openReadingPipe(1,pipes[1]);</p>
<p>// Dump the configuration of the rf unit for debugging
radio.printDetails();
delay(1000);
}</p>
<p>void loop(void)
{
uint8_t Data1,Data2,Data3,Data4 = 0;
char temp[5];
bool timeout=0;</p>
<p>// Get the last two Bytes as node-id
uint16_t nodeID = pipes[0] &amp; 0xff;</p>
<p>char outBuffer[32]=&quot;&quot;; // Clear the outBuffer before every loop
unsigned long send_time, rtt = 0;</p>
<p>// Get readings from sensors, change codes below to read sensors
Data1 = counter++;
Data2 = digitalRead(inPin);</p>
<p>if ( counter &gt; 999 ) counter = 0;</p>
<p>// Append the hex nodeID to the beginning of the payload
sprintf(outBuffer,&quot;%2X&quot;,nodeID);</p>
<p>strcat(outBuffer,&quot;,&quot;);</p>
<p>// Convert int to strings and append with zeros if number smaller than 3 digits
// 000 to 999</p>
<p>sprintf(temp,&quot;%03d&quot;,Data1);
strcat(outBuffer,temp);</p>
<p>strcat(outBuffer,&quot;,&quot;);</p>
<p>sprintf(temp,&quot;%04d&quot;,Data2);
strcat(outBuffer,temp);</p>
<p>printf(&quot;outBuffer: %s len: %d\n\r&quot;,outBuffer, strlen(outBuffer));</p>
<p>send_time = millis();</p>
<p>// Stop listening and write to radio
radio.stopListening();</p>
<p>// Send to hub
if ( radio.write( outBuffer, strlen(outBuffer)) ) {
printf(&quot;Send successful\n\r&quot;);
}
else {
printf(&quot;Send failed\n\r&quot;);
}</p>
<p>radio.startListening();
delay(20);</p>
<p>while ( radio.available() &amp;&amp; !timeout ) {</p>
<p>uint8_t len = radio.getDynamicPayloadSize();
radio.read( receivePayload, len);</p>
<p>receivePayload[len] = 0;
printf(&quot;inBuffer: %s\n\r&quot;,receivePayload);</p>
<p>// Compare receive payload with outBuffer
if ( ! strcmp(outBuffer, receivePayload) ) {
rtt = millis() - send_time;</p>
<p>printf(&quot;inBuffer --&gt; rtt: %i \n\r&quot;,rtt);</p>
<p>}</p>
<p>// Check for timeout and exit the while loop
if ( millis() - send_time &gt; radio.getMaxTimeout() ) {
Serial.println(&quot;Timeout!!!&quot;);
timeout = 1;
}</p>
<p>delay(10);
} // End while</p>
<p>delay(250);
}
[/sourcecode]</p>
<p>This sketch makes use of printf so you need a file in the same directory called printf.h which consists of:</p>
<p>[sourcecode]
/*
Copyright (C) 2011 J. Coliz <a href="&#x6d;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#x6d;&#x61;&#110;&#x69;&#97;&#99;&#x62;&#117;&#103;&#64;&#x79;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;">&#x6d;&#x61;&#110;&#x69;&#97;&#99;&#x62;&#117;&#103;&#64;&#x79;&#109;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#x6d;</a></p>
<p>This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
version 2 as published by the Free Software Foundation.
*/</p>
<p>/<em>*
</em> @file printf.h
<em>
</em> Setup necessary to direct stdout to the Arduino Serial library, which
<em> enables &#39;printf&#39;
</em>/</p>
<h1>ifndef <strong>PRINTF_H</strong></h1>
<h1>define <strong>PRINTF_H</strong></h1>
<h1>ifdef ARDUINO</h1>
<p>int serial_putc( char c, FILE * )
{
Serial.write( c );</p>
<p>return c;
}</p>
<p>void printf_begin(void)
{
fdevopen( &amp;serial_putc, 0 );
}</p>
<h1>else</h1>
<h1>error This example is only for use on Arduino.</h1>
<h1>endif // ARDUINO</h1>
<h1>endif // <strong>PRINTF_H</strong></h1>
<p>[/sourcecode]</p>
<p><h2>Running the code on the RPi and Arduino</h2>
On the Arduino, just compile and upload the sketch and then open the Serial Monitor window and set the baud rate to 57,600.</p>
<p>On the RPi, run the following. It will show you what it is receiving from the Arduino and echoes it back.</p>
<p><pre>sudo /home/pi/gitwork/RF24/librf24-rpi/librf24/examples/rpi-hub</pre>
If everything is working ok, both the RPi and the Arudino should be showing very similar output and reporting success.</p>
<p><h2>Next Steps?</h2>
The Raspberry Pi libraries and sample code are obviously in C which is probably too hardcore for most people. Ideally they&#39;d be available to both Python and JavaScript deveopers. I&#39;ll do a little poking around to see how you go about that. I wouldn&#39;t hold my breath tho.</p>
<p><a href="https://s3-eu-west-1.amazonaws.com/conoroneill.net/wp-content/uploads/2013/09/2013-09-01-14.44.06.jpg"><img class="aligncenter size-full wp-image-1160" alt="2013-09-01 14.44.06" src="https://s3-eu-west-1.amazonaws.com/conoroneill.net/wp-content/uploads/2013/09/2013-09-01-14.44.06.jpg" width="1024" height="768" /></a></p>
<p>I haven&#39;t done any major distance testing on the modules. In our house, which has concrete internal walls, two modules could communicate from one room to the next but not from one end of the house to the other. They also worked successfully with one module inside an oil tank in the garden and the other one inside the house &lt;10m away. I&#39;ll try some open air testing soon.</p>
<aside class="center author"><img src="/images/CliveStrong.jpg" alt="Conor O'Neill"/><h2 class="sm">Conor O'Neill</h2><p>Is an Irish technology guy. One of Ireland's first bloggers.</p><p class="links"><a href="/authors/admin">Posts</a><span>•</span><a href="http://twitter.com/conoro">Twitter</a><span>•</span><a href="https://plus.google.com/+ConorONeill/posts">Google+</a><span>•</span><a href="https://github.com/conoro">GitHub</a></p></aside><section class="comments"><h2>Discuss</h2><div id="disqus_thread"><script>var disqus_shortname = 'conor';
(function() {
  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript><a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a></div></section><nav class="post-nav"><ul class="clearfix"><li><a href="another-big-brain-dump-of-interesting-tech-bits-over-the-past-few-weeks" title="Another big brain dump of interesting tech bits over the past few weeks" class="post-prev"><strong>Previous Post</strong><span>Another big brain dump of interesting tech bits over the past few weeks</span></a></li><li><a href="ah-cmon-is-this-not-the-cutest-raspberry_pi-setup-of-all-time" title="Ah c'mon, is this not the cutest @raspberry_pi setup of all time?" class="post-next"><strong>Next Post</strong><span>Ah c'mon, is this not the cutest @raspberry_pi setup of all time?</span></a></li></ul></nav></article></div></div></body></html>